---
title: "Audio Dashboard - Million Song Dataset"
author: Tiago Teixeira, Jaime Rodrigues
format: 
    dashboard:
        orientation: columns
        scrolling: true
        theme: dark
---

<link rel="stylesheet" href="assets/css/main.css">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""/>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""></script>

<script src="https://d3js.org/d3.v7.min.js"></script>

## Coluna 1 {width=60%}

```{ojs}


dataHigh = FileAttachment("data/high_popularity_spotify_data.json").json()
dataLow = FileAttachment("data/low_popularity_spotify_data.json").json()

all_music = {
    const combined = [
        ...dataHigh.map(d => ({...d, category: "High"})),
        ...dataLow.map(d => ({...d, category: "Low"}))
    ];
    return Array.from(new Map(combined.map(item => [item.track_id, item])).values());
}

viewof search = Inputs.search(all_music, {label: "Procurar música ou artista:"})



//| label: estatisticas-biblioteca
{
    const totalMusicas = all_music.length;
    const generosDistintos = new Set(all_music.map(d => d.playlist_genre)).size;
    const avgPopularity = d3.mean(all_music, d => d.track_popularity).toFixed(1);

    const stats = [
        { label: "TOTAL DE MÚSICAS", value: all_music.length, color: "#0be7d5" },
        { label: "GÉNEROS MUSICAIS", value: new Set(all_music.map(d => d.playlist_genre)).size, color: "#ff4d4d" },
        { label: "POPULARIDADE MÉDIA", value: `${d3.mean(all_music, d => d.track_popularity).toFixed(1)}%`, color: "#ffd700" }
    ];

    return html`${stats.map(s => html`
    <div style="border-top: 4px solid ${s.color}; background: #1e1e1e; padding: 15px; border-radius: 8px;">
      <span style="color: #888; font-size: 0.8em;">${s.label}</span>
      <div style="font-size: 1.5em; font-weight: bold;">${s.value}</div>
    </div>`)}`
}


viewof selectedTrack = Inputs.table(search, {
    columns: ["track_name", "track_artist", "playlist_genre", "track_popularity"],
    header: {
        track_name: "Música",
        track_artist: "Artista",
        playlist_genre: "Género",
        track_popularity: "Popularidade"
    },
    format: {
        track_popularity: p => html`<div style="display: flex; align-items: center; gap: 8px;">
            <div style="width: ${p}px; max-width: 100px; height: 8px; background: ${p > 70 ? '#0be7d5' : '#ffd700'}; border-radius: 4px;"></div>
            <span>${p}%</span>
        </div>`
    },
    layout: "fixed",
    rows: 15,
    multiple: false,
    required: false
})

currentTrack = selectedTrack || search[0] || all_music[0]
```

## Coluna 2 {width=40%}

``` {ojs}
radarData = [
    {axis: "Energy", value: currentTrack.energy },
    {axis: "Dance", value: currentTrack.danceability },
    {axis: "Acoustic", value: currentTrack.acousticness },
    {axis: "Valence", value: currentTrack.valence },
    {axis: "Speech", value: currentTrack.speechiness }
];

{
    // 1. Aumentamos as dimensões e a margem (espaço para o texto)
    const width = 300; 
    const height = 300;
    const margin = 50; // Margem generosa para as labels
    
    const radius = Math.min(width, height) / 2 - margin;
    
    // Criar o SVG com um viewBox que abrange tudo
    const svg = d3.create("svg")
        .attr("viewBox", [0, 0, width, height])
        .style("overflow", "visible");

    const g = svg.append("g")
        .attr("transform", `translate(${width/2},${height/2})`);
    
    const angleSlice = (Math.PI * 2) / radarData.length;
    const rScale = d3.scaleLinear().domain([0, 1]).range([0, radius]);

    // 2. Desenhar as linhas dos eixos
    const axis = g.selectAll(".axis")
        .data(radarData)
        .enter().append("g");

    axis.append("line")
        .attr("x1", 0)
        .attr("y1", 0)
        .attr("x2", (d, i) => rScale(1) * Math.cos(angleSlice * i - Math.PI/2))
        .attr("y2", (d, i) => rScale(1) * Math.sin(angleSlice * i - Math.PI/2))
        .style("stroke", "#999")
        .style("stroke-width", "1px");

    // 3. Adicionar Labels (Com coordenadas explícitas e cor visível)
    axis.append("text")
        .attr("x", (d, i) => rScale(1.25) * Math.cos(angleSlice * i - Math.PI/2))
        .attr("y", (d, i) => rScale(1.25) * Math.sin(angleSlice * i - Math.PI/2))
        .text(d => d.axis)
        .style("font-family", "sans-serif")
        .style("font-size", "16px") // Texto maior
        .style("font-weight", "bold")
        .style("fill", "#0be7d5") // Usar o ciano da tua marca para garantir visibilidade
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em");

    // 4. Desenhar os níveis (círculos tracejados)
    g.selectAll(".grid-circle")
        .data([0.2, 0.4, 0.6, 0.8, 1])
        .enter().append("circle")
        .attr("r", d => rScale(d))
        .style("fill", "none")
        .style("stroke", "#444")
        .style("stroke-dasharray", "4,4");

    // 5. Desenhar o polígono (Área preenchida)
    const radarLine = d3.lineRadial()
        .curve(d3.curveLinearClosed)
        .radius(d => rScale(d.value))
        .angle((d, i) => i * angleSlice);

    g.append("path")
        .datum(radarData)
        .attr("d", radarLine)
        .style("fill", currentTrack.category === "High" ? "#0be7d5" : "#ff4d4d")
        .style("fill-opacity", 0.5)
        .style("stroke", "white")
        .style("stroke-width", "2px");

    return svg.node();
}

{
  const genreAvgEnergy = d3.mean(all_music.filter(d => d.playlist_genre === currentTrack.playlist_genre), d => d.energy);
  
  return Plot.plot({
    title: html`<div style="font-size: 14px; margin-bottom: 10px; color: white;">
                  Energia: <b>${currentTrack.track_name}</b> vs Média de <b>${currentTrack.playlist_genre}</b>
                </div>`,
    height: 120, 
    marginLeft: 20,
    marginRight: 20,
    x: { domain: [0, 1], label: "Nível de Energia →", grid: true },
    marks: [
      // Barra de fundo que representa a média do género
      Plot.barX([genreAvgEnergy], {
        x: genreAvgEnergy, 
        fill: "#333", 
        fillOpacity: 0.8,
        insetTop: 20, 
        insetBottom: 20
      }),
      // Linha vertical branca no ponto exato da média
      Plot.ruleX([genreAvgEnergy], {stroke: "white", strokeWidth: 2.5}),
      // O ponto (dot) que representa a música atual
      Plot.dot([currentTrack.energy], {
          x: d => d, 
          fill: currentTrack.energy > genreAvgEnergy ? "#0be7d5" : "#ff4d4d", 
          r: 8,
          stroke: "white",
          strokeWidth: 2
      }),
      // Textos explicativos
      Plot.text([`Média`], {x: genreAvgEnergy, dy: -40, fill: "#888", fontSize: 11}),
      Plot.text([`Música`], {x: currentTrack.energy, dy: 40, fill: "white", fontWeight: "bold", fontSize: 12})
    ],
    style: { 
      background: "transparent", 
      color: "#ccc",
      fontFamily: "sans-serif",
      overflow: "visible" // Garante que as labels fora do eixo aparecem
    }
  });
}
html`<iframe
    src=${"https://open.spotify.com/embed/track/" + (selectedTrack?.track_id || all_music[0].track_id)}
    width="100%" height="152"
    frameborder="0"
    allowtransparency="true"
    allow="encrypted-media"></iframe>`
{
    let ctx, analyser, dataArray, bufferLength, animationId;

    async function getPreviewUrl(trackId, token) {
        try {
            const r = await fetch(
            `https://api.spotify.com/v1/tracks/${trackId}`,
            { method: 'GET', headers: { Authorization: `Bearer ${token}` } }
            );

            if (!r.ok) return null;

            const data = await r.json();
            return data.preview_url;
        } catch (e) {
            return null;
        }
    }

    const SPOTIFY_TOKEN = 'BQCxU5ZLYipjQEfDhMXY_-jxYmQGRrSDYInpa_FHyL9d98JaeRaiLoI_ZZE-TMWRSEa50f0H6u2SXnkoiEwHR_0850tYLe9k9z1N7n3soPR7JgmtjroNmH1V9Gog_IToxxsNHez_llwtW0uDGx27ADML8LFtnmKKKLZ_faYsf40ICXvmCRp1YyW5TbzU99fpOC7HUXQE1dXtz9Y45rWAEVlS_t7usj7T_Lyh2_SUeErBZnawM8RG6tM1KvCn5OoaSlUh9QjVm3K-aB-isHQf6tkZeC5lmPGWwWxZaattp9Fm7GOF0g';

    const previewUrl = await getPreviewUrl(currentTrack.track_id, SPOTIFY_TOKEN);

    if (!previewUrl) {
        return 'Preview indisponível para esta musica';
    }

    const audio = previewUrl
        ? html`<audio controls crossorigin="anonymous" src="${previewUrl}"></audio>`
        : html`<div style="color:#888; font-size:0.8em;">Preview indisponível</div>`;

    const canvas = html`
        <canvas width="400" height="120"
        style="width:100%; background:#1a1a1a; border-radius:8px;">
        </canvas>`;
    const canvasCtx = canvas.getContext("2d");

    function draw() {
        animationId = requestAnimationFrame(draw);
        analyser.getByteTimeDomainData(dataArray);

        canvasCtx.fillStyle = "#1a1a1a";
        canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = "#0be7d5";
        canvasCtx.beginPath();

        const sliceWidth = canvas.width / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0;
        const y = (v * canvas.height) / 2;

        if (i === 0) canvasCtx.moveTo(x, y);
        else canvasCtx.lineTo(x, y);

        x += sliceWidth;
        }

        canvasCtx.stroke();
    }

    if (previewUrl) {
    audio.onplay = () => {
      if (!ctx) {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = ctx.createAnalyser();
        const source = ctx.createMediaElementSource(audio);
        source.connect(analyser);
        analyser.connect(ctx.destination);
        analyser.fftSize = 1024;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        draw();
      } else if (ctx.state === 'suspended') {
        ctx.resume();
      }
    };
  }


  return html`
    <div style="padding:15px; background:#222; border-radius:12px; border:1px solid #333;">
      <h6 style="margin:0; color:#888; font-size:0.7em; text-transform:uppercase;">Sinal de Áudio:</h6>
      <div style="font-weight:bold; color:white; margin-bottom:10px;">${currentTrack.track_name}</div>
      ${audio}
      ${canvas}
      <div style="margin-top:10px; padding:8px; background:#1a1a1a; border-radius:6px; border-left:4px solid #0be7d5;">
        <span style="font-size:0.75em; color:#aaa;">Domínio do Tempo (Waveform) - 30s preview</span>
      </div>
    </div>
  `;
}
```
